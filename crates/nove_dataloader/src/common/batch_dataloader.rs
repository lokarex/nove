use derive_builder::Builder;
use rand::{SeedableRng, rngs::StdRng, seq::SliceRandom};

use crate::{Dataloader, DataloaderError};
use nove_dataset::Dataset;

/// The `BatchDataloader` struct provides a basic data loader to
/// shuffle the dataset, load the data, process the data, and collate the
/// datas into batches.
///
/// # Note
/// * When create a `BatchDataloader` from `BatchDataloaderBuilder`(Generated by `derive_builder`),
///   the specific `BatchDataloader` type must be determined. It means
///   3 generic type parameters must be set manually, so please clearly
///   learn about the generic type parameters of `BatchDataloader`.
/// * The `BatchDataloaderBuilder` needs some necessary parameters including
///   `dataset`, `batch_size`, `process_fn`, and `collate_fn`. It also provides
///   an optional parameter `shuffle_seed` with default value `None` (no shuffling).
///
/// # Lifetime Parameters
/// * `'a` - The lifetime of the inner dataset.
///
/// # Generic Type Parameters
/// * `D`(Need to be manually set) - The type of the inner dataset.
/// * `O`(Need to be manually set) - The type of the processed data which is the output of the process function.
/// * `B`(Need to be manually set) - The type of the batched data which is the output of the collate function
///    and the final output of the dataloader.
/// * `P` - The type of the process function. It needs a function that takes
///    an item(The `D::Item` type) from the dataset as input and returns the processed
///    data(The `Result<O, DataloaderError>` type) as output.
/// * `C` - The type of the collate function. It needs a function that takes
///    a vector of processed data(The `Vec<O>` type) from the process function as input and returns
///    the batched data(The `Result<B, DataloaderError>` type) as output.
///
/// # Fields
/// * `dataset` - The inner dataset.
/// * `batch_size` - The batch size.
/// * `process_fn` - The process function.
/// * `collate_fn` - The collate function.
/// * `index` - The current index.
/// * `shuffle_seed` - The shuffle seed.
/// * `indices` - The indices of the dataset which would be shuffled before the first batch if the shuffle_seed is not `None`.
/// * `datas` - The processed data.
/// * `phantom` - The phantom data only used to marks that the `B` generic type parameter which would be used later.
#[derive(Builder)]
pub struct BatchDataloader<'a, D: Dataset, O, B, P, C> {
    dataset: &'a dyn Dataset<Item = D::Item>,
    batch_size: usize,
    process_fn: P,
    collate_fn: C,
    #[builder(default = "None")]
    shuffle_seed: Option<usize>,
    #[builder(setter(skip), default = "0")]
    index: usize,
    #[builder(setter(skip), default = "Vec::new()")]
    datas: Vec<O>,
    #[builder(setter(skip), default = "Vec::new()")]
    indices: Vec<usize>,
    #[builder(setter(skip), default = "std::marker::PhantomData::<B>::default()")]
    phantom: std::marker::PhantomData<B>,
}

impl<'a, D: Dataset, O, B, P, C> BatchDataloader<'a, D, O, B, P, C>
where
    P: Fn(D::Item) -> Result<O, DataloaderError>,
    C: Fn(Vec<O>) -> Result<B, DataloaderError>,
{
    /// Shuffle the indices of the dataloader.
    ///
    /// # Arguments
    /// * `seed` - The seed to shuffle the indices.
    fn shuffle_indices(&mut self, seed: usize) {
        self.indices
            .shuffle(&mut StdRng::seed_from_u64(seed as u64));
    }
}

impl<'a, D: Dataset, O, B, P, C> Dataloader for BatchDataloader<'a, D, O, B, P, C>
where
    P: Fn(D::Item) -> Result<O, DataloaderError>,
    C: Fn(Vec<O>) -> Result<B, DataloaderError>,
{
    type Output = B;

    fn next(&mut self) -> Result<Option<Self::Output>, DataloaderError> {
        let dataset_len = self.dataset.len()?;

        if self.indices.is_empty() {
            self.indices = (0..dataset_len).collect();
        }

        // Shuffle the indices before the first batch.
        if self.index == 0 && self.shuffle_seed.is_some() {
            self.shuffle_indices(self.shuffle_seed.unwrap());
        }

        if self.index >= dataset_len {
            return Ok(None);
        }

        for _ in 0..self.batch_size {
            if self.index >= dataset_len {
                break;
            }
            let item = self.dataset.get(self.indices[self.index])?;
            self.datas.push((self.process_fn)(item)?);
            self.index += 1;
        }

        Ok(Some((self.collate_fn)(std::mem::take(&mut self.datas))?))
    }

    fn reset(&mut self) -> Result<(), DataloaderError> {
        self.index = 0;
        Ok(())
    }
}
